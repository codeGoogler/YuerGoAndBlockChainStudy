
并行：依赖硬件完成统一时刻，同时运行多个程序。 真正的多任务。

并发：依赖cpu高速运算特性，同时运行多个程序。 伪的多任务。

程序：
	磁盘上存储着的，二进制的可执行文件。（死的）

进程：
	运行起来的程序。占用系统资源（内存（用户内存heap、系统内存））

	一个程序要想运行，必须要有“进程地址（虚拟地址）空间”， 所有系统都一样

对应关系：

	1 程序		1程序
	    |		   |
	1 进程		N进程

进程并发：
	提高单位时间内，获得 cpu 的概率。

进程的状态：

	初始态、就绪态、运行态、挂起态、终止态 【重点】

	2 ^32 = 4G

	2 ^64 = 16777216TB

----------------------------

线程：
	进程：最小 资源分配（虚拟地址空间）单位

	线程：最小 执行单位（cpu按线程来划分 时间片）

	线程同步： 多个线程 同时 访问同一个共享资源，有可能对该资源造成修改时，所采用的一种协调保护机制。

		 指定访问共享资源的 先后顺序。  ―― 避免数据混乱。

	锁： 操作系统提供给用户使用的所有的 “锁”，都是 “建议锁”，不具有强制性。

同步方法 ―― 互斥锁：

	多个控制流访问同一共享资源时，首先拿锁（互斥锁、互斥量）。拿锁成功后，方可访问共享数据。否则阻塞等待。

	直到持有锁的控制流，释放锁的使用权。再次尝试加锁。

同步方法 ―― 读写锁：

	读共享、写独占。写锁优先级高于读锁。	

	读写锁，是锁的一种。一个读写锁只有一把。有两种加锁状态。

---------------------------------------

协程：
	较新语言 Python、Lua、Rust

	协程优点：
		1. 不需要提供栈帧。没有调用、释放一说。  -- 微线程

		2. 不需要提供新内存资源

	缺点：依赖线程、进程。

		线程 ―― 独立的控制流。 

		线程并发 ―― 多个独立控制流访问 cpu

	协程充分利用 线程、进程 等待的时间，去完成其他操作。最大化提供cpu的使用率。

-----------------------------------------

总结：进程、线程、协程：

	都可以实现并发。 进程资源消耗最大，线程次之，协程最小。

	进程：稳定性最高。

	线程：开销小、切换方便。

	协程：充分利用 线程、进程等待时间。  程序中有更多 IO 操作。

	例子： 	手机厂老板。

		购置生产线。―― 进程。

		招一个工人。 ―― 线程。

		招 10 个工人。 ―― 单进程、多线程。

		购置 5 条生产线、500 个工人。 ―― 多进程、多线程。

		所有生产线工人，闲暇时间。去老板家搬砖盖楼。―― 协程。

-------------------------------------

go程：
	创建方法：在 函数调用之前 添加“go”关键字。

	―― 练习：子go程、匿名子go程、主go程。 输出。

	主、子go程通信特性：【重点】
	
		主go程结束运行，导致，进程地址空间释放， 那么子go程不再运行。

runtime包：

	1. Gosched:	
		主动出让当前 go 程 的 cpu 使用权 一次。

	2. Goexit：
		return：将当前函数调用  返回 给调用。

 		runtime.Goexit： 将当前 go 程结束。

		os.Exit：将当前 进程 退出。―― 进程地址空间消失。

	3. GOMAXPORCS:

		设置cpu核数。

		返回值，返回上次设置成功的数量。初次调用返回，默认的 逻辑cpu核数。

		
		
		


























